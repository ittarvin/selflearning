package dijkstra;

/**
 * 1965年 Dijkstra 提出了一种能够避免死锁的资源分配算法。
 * 基本思想是一个进程提出申请资源后，系统要进行资源的试分配。
 * 然后检测本次的试分配是否使系统处于安全状态，
 * 若安全则按照试分配方案分配资源，否则不分配资源。
 *
 * @author Arvin
 * @date 2021/03/07
 *
 */
public class Banker {

    //1.数据结构

    // 用 m 表示系统中资源的种类数，n 表示系统中的进程数。
    int m = 10;
    int n = 5;

    /**
     * 一维数组，表示系统中某些资源的可用数量，也就是这种资源的可分配的数量。
     * available[j] = k 表示 j 类资源的可用数量为 k，系统可用为进程分配 j 类资源为 k 个。
     */
    int available[];

    /**
     * 表示各进程需要各类资源的最大数量。
     * max[i][j] = k  表示进程 Pi 需要j 类资源的最大数量为 k 个。
     */
    int max[][];

    /**
     * 表示某个时刻已经分配给进程的某类资源数量 。
     * allocation[i][j] = k 表示进程 Pi 已经占有 j 类资源 k 个。
     */
    int allocation[][];

    /**
     * 表示进程还需要某类资源数量。
     * need[i][j] = k 表示进程 Pi 还需要 j 类资源 k 个。
     */
    int need[][];


    /**
     * 银行家算法分为两个过程
     * 第一，进行自娱试分配过程。
     * 第二，对试分配后的系统状态做安全性检测过程。
     * 经过安全性检测，若分配后系统状态是安全的，则分配资源。若不安全，则阻塞申请资源的进程，暂不为它分配资源。
     */

    /**
     * 简化银行家算法描述，采用一些记号。设 X 和 Y 是长度为 n（n 代表系统中的进程数） 的向量，
     *
     */


}
