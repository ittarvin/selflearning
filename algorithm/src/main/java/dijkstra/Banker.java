package dijkstra;

/**
 * 1965年 Dijkstra 提出了一种能够避免死锁的资源分配算法。
 * 基本思想是一个进程提出申请资源后，系统要进行资源的试分配。
 * 然后检测本次的试分配是否使系统处于安全状态，
 * 若安全则按照试分配方案分配资源，否则不分配资源。
 *
 * @author Arvin
 * @date 2021/03/07
 *
 */
public class Banker {

    //1.数据结构

    // 用 m 表示系统中资源的种类数，n 表示系统中的进程数。
    int m = 10;
    int n = 5;

    /**
     * 一维数组，表示系统中某些资源的可用数量，也就是这种资源的可分配的数量。
     * available[j] = k 表示 j 类资源的可用数量为 k，系统可用为进程分配 j 类资源为 k 个。
     */
    int available[];

    /**
     * 表示各进程需要各类资源的最大数量。
     * max[i][j] = k  表示进程 Pi 需要j 类资源的最大数量为 k 个。
     */
    int max[][];

    /**
     * 表示某个时刻已经分配给进程的某类资源数量 。
     * allocation[i][j] = k 表示进程 Pi 已经占有 j 类资源 k 个。
     */
    int allocation[][];

    /**
     * 表示进程还需要某类资源数量。
     * need[i][j] = k 表示进程 Pi 还需要 j 类资源 k 个。
     */
    int need[][];


    /**
     * 银行家算法分为两个过程
     * 第一，进行资源试分配过程。
     * 第二，对试分配后的系统状态做安全性检测过程。
     * 经过安全性检测，若分配后系统状态是安全的，则分配资源。若不安全，则阻塞申请资源的进程，暂不为它分配资源。
     */

    /**
     * 简化银行家算法描述，采用一些记号。设 X 和 Y 是长度为 n（进程） 的向量，
     *
     * 当且仅当所有 i = 1，2... n , X[i] < Y[i],则有 X < Y。
     * 例如，如果 X = （0，3，2，1）而且 Y = （1，7，3，2），那么 X < Y。
     * 当且仅当所有 i = 1，2... n，X[i] = Y[i], 则 X = Y。
     *
     * 将矩阵 allocation_i 和 need  的每一行作为向量，并分别用 allocation_i 和 need_i 来表示。
     * 向量 allocation_i 表示已经分配给进程 Pi 的各类资源数量，
     * 向量 need_i，表示进程 Pi 为完成其任务可能需要申请的各类资源数。
     */

    /**
     * 1.资源试分配算法
     *
     * 设 request_i 为进程 Pi 的请求向量。如果 request_i[j] = k ,那么进程 Pi 向系统请求 j 类资源 k 个。
     * 当进程 Pi 提出资源请求后，系统从资源的试分配程序开始执行，资源试分配算法如下。
     *
     *  i 表示进程序列 i = 1，2... n。
     *  j 表示资源类型
     *  @throws Exception
     */
    public void tryAllocate() throws Exception {

        /**
         * 1.如果 request_i <= need_i ,那么转到底2步。否则，产生出错条件。
         */


        /**
         * 2.如果 request_i <= available,说明系统可以满足进程提出的资源请求，那么转到到第3步。
         * 否则，说明系统缺乏可用资源，不能满足进程的资源请求，则阻塞进程Pi。
         */


        /**
         * 3.执行资源试分配
         * available = available - request_i
         * allocation_i = allocation_i + request_i
         * need_i = need_i - request_i
         */

        /**
         *4.转安全性检测过程，如果检测结果是安全的，则确认本次试分配，否则，进程 Pi必须等待，系统取消资源试分配，
         * 恢复原来的分配状态。
         */


    }


    /**
     * 2.安全性检测算法
     * 安全性检测算法用来判断系统资源分配状态是否安全，算法需要的数据结果如下。
     */

    /**
     * 是一个大小为 m 的数组，进入安全的检测过程时被初始为当前的 available 。
     */
    int work[];

    /**
     * 是一个大小为 n 的数组，进入安全检测过程时，对所有  i = 1，2... n， finish[i] = false。
     */
    int finish[];


    /**
     * 确定是否存在至少一个安全序列。
     * 检测方式是对进程集合中的每一个进程，只要还有一个进程未 “执行” 时，
     * 在未 “执行” 进程集合中找一个当前可以运行的进程，其所需资源数量 need 小于当前可用资源数量 work。
     * 若能找到这样的进程，则置其可执行标记 finish[i] = true,并令进程释放资源，增加系统可用资源数量，进入下一个循环。
     * 找不到符合条件的进程，则说明改分配方案不安全，因此结算循环。
     * 当找到可执行的进程时，检测算法的每次都在“考虑”：这个进程如果可用投入运行的化，它运行并释放资源后，系统中可分配总资源 work
     * 在获的一次累加之后，能否满足另外一个进程的资源请求。
     *
     * @throws Exception
     */
    public void safeCheck() throws Exception {

        /**
         *  1.查找 i 使其满足条件。
         *  finish[i] == false ,并且 need_i <= work,如果没有满足条件 i 的存在则跳转达到第 3步。
         */

        /**
         * 2.如果找到满足条件的 i ，执行下列操作
         * work = work + allocation_i
         * finish[i] = true;
         */

        /**
         * 3.对所有的 i finish[i] = true,那么系统处于安全态，否则，系统处于不安全状态。
         */

    }

}
